# 5.인터럽트



![](https://velog.velcdn.com/images/hunsik0302/post/717c579c-91b3-424c-a892-7081efbef378/image.png)

CPU는 특별한 일이 없으면 현재 수행 중인 프로세스의 다음명령을 순차적으로 수행한다.
CPU는 멍청해서 프로그램 카운터가 가리키는 곳에 있는 명령을 수행하는 일만 하기 때문에, 현재 수행 중인 프로세스로부터 CPU를 회수해 CPU가 다른일을 수행하도록 하기 위해서는 인터럽트 메커니즘이 필요로 한다.

CPU는 매번 프로그램 카운터가 가리키고있는 지점의 명령을 수행한후 인터럽트 라인 체크를 통해 인터럽트를 체크하고, 인터럽트가 발생했으면 CPU는 현재 수행하던 프로세스를 멈추고 운영체제의 인터럽트 처리루틴으로 이동해서 인터럽트를 처리한다. 원칙적으로는 인터럽트 처리 중에 또다른 인터럽트가 발생하게되면 데이터의 일관성이 유지 되지 않는 문제가 발생할 수 있기 떄문에 중복을 허용하지 않는다. 하지만 예외가 존재할 필요가 있는데
인터럽트마다 중요도가 다르기 때문에 상대적으로 낮은 중요도를 가진 인터럽트를 처리하는 도중에 중요도가 높은 인터럽트가 발생하는 것을 허락할 필요가 있다. 중요도가 더 높은 인터럽트가 발생하면 이것도 똑같이 처리 중이던 인터럽트 코드 수행 지점을 저장하고 우선 순위가 높은 인터럽트부터 처리하게 된다.


# 6.시스템콜

![](https://velog.velcdn.com/images/hunsik0302/post/2628b1f8-848d-493f-88ba-f5959af30271/image.png)


모든 프로그램은 자기 자신의 독자적인 주소 공간을 가지고 있으며 프로그램이 함수 호출을 하는 경우 자신의 주소 공간 내에서 호출이 이루어짐.
시스템 콜은 함수호출이기는 하지만 자신의 주소 공간을 거스르는 영역에 존재하는 함수를 호출하는 것을 말함.
쉽게 말하면 커널이라는 다른 프로그램의 주소 공간에 존재하는 함수를 호출하는 것.
시스템 콜 사용ex) 디스크 파일을 읽어와야 할 경우 시스템 콜로 커널을 호출하고, 사용자 프로그램은 운영체제에게 CPU 제어권을 넘기고 이 과정은 인터럽트 라인을 통해 이루어지며 CPU는 다음 명령을 수행하기전에
인터럽트가 발생했는지 점검하고 발생했으면 사용자 프로그램을 멈춘후 입출력 과정을 수행한다.
디스크 컨트롤러가 디스크에서 데이터를 읽어오는 일은 시간이 많이 소요되기 떄문에 효율성을 위해 CPU의 제어권을 다른 프로세스에게 이양한다. 이행된 CPU에서 명령을 수행하던중 입출력 작업이 완료되면 인터럽트를 발생시켜 완료 되었음을 알리면 작업을 멈추고 정보를 저장한후 입출력을 했던 CPU에게 제어권이 넘어간다.

결론은 타이머에 의해 인터럽트가 발생하는경우와, 시스템콜을 하는 경우에 CPU 제어권을 넘겨주게 된다.
여기서 타이머는 시분할 시스템 구현을 위한 필수적인 요소라고 할수있다.


# 7.프로세스의 두 가지 실행 상태

- 사용자모드

- 커널모드

위 두개의 실행 상태가 있는데 프로그램이 시작되어 종료될 때까지 다양한 함수들을 호출한다.
프로그램이 사용자 정의함수나 라이브러리 함수를 호출할 때는 모드의 변경없이 사용자 모드에서 실행을 하고,
시스템 콜을 하는 경우에는 커널모드로 진입해 커널주소의 공간에 정의된 함수를 실행한다.
시스템 콜의 실행이 끝나면 다시 사용자 모드로 복귀해서 시스템 콜이후의 명령을 실행한다.

Running state
- 필요한 자원 및 프로세서를 모두 할당 받은 상태. 프로세서를 차지하고 작업을 실행 중인 상태

